### 操作系统考点

#### 操作系统

##### 什么是操作系统？简要概述

* 操作系统是管理计算机**硬件和软件资源**的计算机程序，提供一个计算机用户与计算机硬件系统之间的**接口**。
* 向上对用户程序提供接口，向下接管硬件资源。
* 操作系统本质上也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。

##### 操作系统分类

​	常规：批处理操作系统、分时操作系统、实时操作系统。

​	若一个操作系统兼顾批操作和分时的功能，则称该系统为通用操作系统

​	常见的通用操作系统有：Windows、Linux、MacOS等。

##### 什么是内核态和用户态

​	为了避免操作系统和关键数据被用户程序破坏，将**处理器的执行状态**分为内核态和用户态。用户程序运行在用户态，操作系统内核运行在内核态。

​	**内核态**：是操作系统管理程序执行时所处的状态，能够执行包含**特权指令**在内的**一切指令**，能够访问系统内**所有的存储空间**。

​	**用户态**：是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问**用户地址空间**。

###### 内核态和用户态的切换

​	处理器从用户态切换到内核态的方法有三种：**系统调用、异常和外部中断**。

* **系统调用**：系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种**软中断**。
* **异常**：也叫做**内中断**，是由错误引起的，如文件损坏、缺页故障等。
* **外部中断：**通过两根信号线来通知处理器外设的状态变化，是**硬中断**。中断由处理器**外部**的**硬件**产生，不是执行某条指令的结果，也无法预测发生时机。
  * 中断包括 I/O 设备发出的 I/O 中断、各种定时器引起的时钟中断、调试程序中设置的断点等引起的调试中断等。


##### 并行和并发

​	**并发：**指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。

​	但是从微观上看两个程序的指令是交织着运行的，**指令之间交错执行**，在单个周期内只运行了**一个**指令。这种并发并不能提高计算机的性能，只能提高效率（如降低某个进程的相应时间）。

​	**并行：**指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核 ，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。

​	这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。



#### 进程和线程

##### 进程

​	进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context） 中。

​	**context上下文**：是由**程序正确运行所需的状态**组成的。这个状态包括存放在内存中的程序的代码和数据，它的 栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。(打开现有文件或新建一个文件时，内核会返回一个文件描述符，文件描述符用来指定已打开的文件)

​	进程由以下部分组成：

* 进程控制块PCB：是进程存在的唯一标志，包含进程标识符PID，进程当前状态，程序和数据地址，进程优先级、CPU现场保护区（用于进程切换），占有的资源清单等。
* 程序段
* 数据段

###### 进程的基本操作



##### 进程和线程有什么区别？

* 进程是资源**分配**的基本单位，线程是**调度**的基本单位。
* 线程依赖于进程存在，一个进程至少有一个线程。
* 进程有自己的**独立地址空间**，线程共享所属进程的地址空间。
* 进程是拥有系统资源的一个**独立**单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如**程序计数器,一组寄存器和栈**)，和其他线程共享本进程的相关资源如**内存、I/O、cpu**等；
* 进程**切换的开销**远大于线程切换的开销
  * 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置。
  * 而线程切换只需保存和设置少量的寄存器的内容，并**不涉及存储器管理**方面的操作
    * 线程有自己的寄存器和栈。当上下文切换的时候，正在运行的线程会将寄存器的状态保存到 **TCB**（Thread Control Block）里（进程是 PCB，Process Control Block），然后恢复另一个线程的上下文。
* 线程之间的**通信**更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行。
* 多进程更加健壮
  * 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间

###### 同一进程中的线程可以共享哪些数据？

* 进程代码块
* 进程的公有数据(全局变量、静态变量等)
* 进程打开的文件描述符
* 进程的当前目录
* 信号处理器/信号处理函数：对收到的信号的处理方式
* 进程ID与进程组ID

###### 线程独占哪些资源？

* 线程ID
* 一组寄存器的值
* 线程自身的栈
* 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改
* 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）

###### 为什么需要线程

​	进程切换的时候会整体切换，开销很大。如果我们**只切换必需的、与处理机相关的信息**，就可以有效减少开销。这种情况下，处理机分配的单位和其他的资源分配的单位不能再是一个实体。

​	由此引入线程：把一个进程分为多个执行任务的单元体，只为其分配处理机，这些执行任务的单元体就是线程。

##### 进程调度的时机

* 当前运行的进程运行结束。
*  当前运行的进程由于某种原因阻塞。
*  执行完系统调用等系统程序后返回用户进程。
* 在使用抢占式调度的系统中，具有更高优先级的进程就绪时
* 分时系统中，分给当前进程的时间片用完。

##### 不能进行进程调度的情况

1. 中断处理程序执行时
2. 在操作系统的内核程序临界区内。
3. 其他需要完全屏蔽中断的原子操作过程中。

###### 进程调度的策略

* 先到先服务调度算法
* 短作业优先调度算法
* 优先级调度算法
* 时间片轮转调度算法
* 高响应比优先调度算法
* 多级队列调度算法
* 多级反馈队列调度算法

###### 进程调度策略的基本设计指标

* CPU利用率
* 系统吞吐率：单位时间内CPU完成的任务占比
* 响应时间
* 周转时间：是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键。
  * 平均周转时间
  * 带权周转时间
  * 平均带权周转

##### 进程的状态

​	进程在运行时有三种基本状态：就绪态、运行态和阻塞态。

* **运行态**(running)：进程获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。

* **就绪态**（ready）：进程具备运行条件，**等待系统分配处理器**执行的状态。 当进程已分配到除 CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪状态。

  在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为**就绪队列**。

* **阻塞（wait）态**：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。

###### 进程状态的切换

* **就绪→执行**： 处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变 成执行状态。 
* **执行→就绪**： 处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。 
* **执行→阻塞**： 正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。
* **阻塞→就绪**： 处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。

##### 什么是孤儿进程？僵尸进程

###### **孤儿进程**

​	 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被`init`进程（1号 进程）所收养，并由`init`进程对他们完成状态收集工作。

###### 僵尸进程

​	进程使用`fork`创建子进程，如果子进程退出，而父进程并没有调用`wait` 获`waitpid `获取子进程的状态信息，那么**子进程的进程描述符**仍然保存在系统中的这些进程是僵尸进程。



##### 进程间的通信方式

###### 简述进程间通信方法

​	每个进程各自有不同的用户地址空间,任何一个进程的全局变量对于其他进程来说都是隔离的，所以进程之间要交换数据必须通过内核。

​	**在内核中开辟一块缓冲区**，进程A把数据从**用户空间拷到内核缓冲区**，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。

​	不同进程间的通信本质：进程之间可以看到一份公共资源而提供这份资源的**形式或者提供者不同**，造成了通信方式不同。

​	进程间通信主要包括管道、系统IPC（InterProcess Communication，包括消息队列、信号量、信号、共享内存等）、以及套接字 socket。

###### 管道(Pipe)

​	管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。

**匿名管道**

​	”|“是**管道**的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。

​	管道是**半双工的**，这种通信方式是**单向**的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道或者使用有名管道(FIFO)。

**有名管道**

​	有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，**以有名管道的文件形式存在于文件系统中**，这样，**即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信**，因此，通过有名管道不相关的进程也能交换数据

​	**有名管道的名字存在于文件系统中，内容存放在内存中。**即存在于实际的磁盘介质或者文件系统。

**管道有以下特点：**

* **其本质是一个伪文件**(管道对于管道两端的进程而言就是一个文件，实为内核缓冲区)

* **只能用于父子进程或者兄弟进程之间**(具有亲缘关系的进程);
*  **由两个文件描述符引用，一个表示读端，一个表示写端。**(可看作循环队列实现的缓冲区)
* **规定数据从管道的写端流入管道，从读端流出。**一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

**管道的局限性**

1. 数据一旦被读走，便不在管道中存在，不可反复读取
2.  由于管道采用半双工通信方式。因此，数据只能在一个方向上流动。
3. 匿名管道只能在有亲缘关系的进程间使用管道。
4. 管道传输的数据是**无格式的字节流且大小受限**。(读出方和写入方必须事先约定好数据的格式。管道缓冲区有限，在管道创建时为缓冲区分配一个页面大小)

###### 信号(signal)

​	**用于通知接收进程某个事件已经发生。**一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的30 种不同类型的信号。 每种信号类型都对应于某种系统事件。

​	对于**异常情况下的⼯作模式，就需要⽤ 「信号」的⽅式来通知进程。**

* 发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：

  * 内核检测到一个系统事件，比如除零错误或者子进程终止。
  * —个进程调用了kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号 给它自己。

* 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。

  ​	进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序(signal handler)的用户层函数捕获这个信号。

###### 消息队列

​	消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。

​	与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。

**消息队列的局限**：

​	这种通信方式有缺点吗？答是有的，如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味**发送消息（拷贝）**这个过程需要花很多时间来读内存。

​	**消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺陷。**

###### 共享内存

​	**共享内存**这个通信方式就可以很好着解决**拷贝**所消耗的时间了。

​	借助虚拟内存，**拿出⼀块虚拟地址空间来，映射到相同的物理内存**中。这样这个进程写⼊的东⻄，另外⼀个进程⻢上就能看到了，都不需要拷⻉来拷⻉去，传来传去，⼤⼤提⾼了进程间通信的速度。

​	

###### **进程如何通过共享内存通信？**

​	多个进程可以访问**同一块内存空间**，不同进程可以及时看到对方进程中对共享内存中数据得更 新。这种方式需要依靠某种同步操作，如**互斥锁和信号量**等。

* 共享内存是**最快**的一种IPC，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。
* 因为多个进程可以同时操作，所以需要进行同步处理。
*  信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

###### 信号量(semaphore):

​	共享内存就是多进程竞争内存的问题，如果多个进程同时修改同⼀个共享内存则很有可能发送冲突了，可能导致数据覆盖脏写，类似于我们平时说的**线程安全**问题。

​	信号量是一个计数器，**表示资源的数量**，用于多进程对共享数据的访问，信号量的意图在于进程间同步。

​	控制信号量的两个操作PV，**P操作会信号量-1，V操作会V操作+1，P 操作是⽤在进⼊共享资源之前，V 操作是⽤在离开共享资源之后，这两个操作是必须成对出现的。**

###### 互斥量

* 当初始化为资源数的时候就是信号量，（为了实现了同步）	
* 当初始化为0的时候，就是mutex互斥量，可以保证所有的资源只可以被一个人操作。

###### 套接字(socket)

​	Socket 通信不仅可以跨⽹络与不同主机的进程间通信，还可以在同主机上进程间通信。可根据创建 Socket 的类型不同，分为三种常⻅的通信⽅式，

* 基于 TCP 协议的通信⽅式
* 是基于 UDP协议的通信⽅式
* 本地进程间通信⽅式。

​	套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，**简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程**。

##### 进程和线程的基本 API

​	<img src="https://s2.loli.net/2022/08/05/onm2dcG4P3p7eYt.png" alt="image-20220805111906511" style="zoom:80%;" />

##### 多线程模型

* 多对一：将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理， 效率较高。缺点就是若一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。
* 一对一：一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执 行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的 内核线程数目也给线程切换带来额外的负担。**linux和Windows**操作系统家族都是使用一对一模型。
* 多对多：将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特 点。

##### 进程互斥

###### 临界区

​	由于多线程执行操作共享变量的这段代码可能会导致竞争状态，因此我们将此段代码称为**临界区（critical section），它是访问共享资源的代码片段，一定不能给多线程同时执行。**

###### 互斥

​	由临界区的概念可知，我们希望临界区的代码段是互斥的，即在任意时刻最多只能有一个线程执行。(其他线程将被阻塞)

##### 进程同步问题

​	互斥解决了并发进程/线程对临界区的使用问题，而同步则是想要保证一定的执行顺序，**即并发进程/线程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通信息称为进程/线程同步**。

​	进程的同步是目的，而进程间通信是实现进程同步的手段

###### 管程Monitor



###### 生产者-消费者问题

###### 哲学家就餐问题

<img src="C:\Users\Tangerine\AppData\Roaming\Typora\typora-user-images\image-20220806121454144.png" alt="image-20220806121454144" style="zoom: 50%;" />

###### 读者-写者问题

###### 临界区

###### 同步与互斥

###### 并发、并行、异步

##### 进程同步的方法

​	操作系统中，进程是具有不同的地址空间的，两个进程是不能感知到对方的存在的。有时候，需要多个 进程来协同完成一些任务。当多个进程需要对同一个内核资源进行操作时，这些进程便是竞争的关系，操作系统必须协调各个进程 对资源的占用，进程的互斥是解决进程间竞争关系的方法。

###### 互斥

 	指若干个进程要使用同一共享资源时，任何时刻最多允许**一个**进程去使用，其他要使用该资源的进程必须**等待**，直到占有资源的进程释放该资源。

###### 同步

​	当多个进程协同完成一些任务时，不同进程的执行进度不一致，这便产生了进程的同步问题。

​	需要操作系统干预，在特定的同步点对所有进程进行同步，这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步。进程互斥本质上也是一种进程同步。

###### 进程同步方法

1. 互斥锁
2. 读写锁
3. 条件变量
4. 记录锁(record locking)
5. 信号量
6. 屏障(barrier)

###### 线程同步的方法

​	操作系统中，属于同一进程的线程之间具有相同的地址空间，线程之间共享数据变得简单高效。但遇到竞争的线程同时修改同一数据或是协作的线程设置同步点的问题时，需要使用一些线程同步的方法来解决这些问题。

1. 互斥锁
2. 读写锁
3. 条件变量
4. 信号量
5. 自旋锁
6. 屏障(barrier)

##### 进程同步和线程的区别

​	进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共 享同一地址空间，同步时把锁放在所属的同一进程空间即可。

##### 死锁的产生

​	死锁是指两个或两个以上进程在执行过程中因争夺资源而造成的相互等待的现象。

###### 产生死锁的四个条件

1. **互斥条件**：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。
2. **占有并等待条件**：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞但该进程不会释放自己已经占有的资源。
3.  **非抢占条件：**进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放。
4.  **循环等待条件**：进程发生死锁后，必然存在一个进程-资源之间的环形链。

###### 如何解决死锁

​	解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下：

1. **破坏请求条件**：资源一次性分配，这样就不会再有请求了
2. **破坏占有并等待条件：**只要有当前占有的资源没有释放，就不给这个进程分配其他的资源。
3. **破坏不可抢占：**可抢占资源，即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可抢占的条件。
4. **破坏循环等待**：.资源有序分配法，系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反， 从而破坏环路等待的条件。

