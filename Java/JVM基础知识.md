## JVM基础知识

### 整体架构

<img src="https://s2.loli.net/2022/07/05/e6jH1gZpVvtdCP7.png" alt="image-20220705100554374" style="zoom:50%;" />



* ClassLoader
* 内存结构：方法区、堆、虚拟机栈、本地方法栈
* 执行引擎：解释器、JIT、GC
* 本地方法接口(C、C++实现)



#### 内存结构

##### 程序计数器

​	program counter，用来存储下一条JVM字节码的地址，物理层面由寄存器组成。

* 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的jvm字节码指令的地址；

* 如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是**唯 一**一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域

特点：

* 线程私有：
  * CPU会为每个线程分配时间片，当前线程的时间片使用完以后，CPU执行另一个线程中的代码。
  * 程序计数器是**每个线程**所**私有**的。当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以得到下一条指令的的地址，知道接下来应该执行哪一句指令。
* 不存在内存溢出

##### 虚拟机栈

​	虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都 会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。

* 每个**线程**运行需要的内存空间称为虚拟机栈。
* 每个栈可由多个**栈帧**组成，每个栈帧对应调用方法时所占用的内存。
* 每个线程只有一个对应其当前正在执行的方法的栈帧，称为活动栈帧。

###### 栈内存溢出

​	**Java.lang.stackOverflowError** 栈内存溢出。

​	**溢出原因：**

* 虚拟机栈中，**栈帧过多**（无限递归）
* 每个栈帧**所占用内存过大**

##### 本地方法栈

​	因为JAVA有时候没法直接和操作系统底层交互，一些带有**native关键字**方法就是需要JAVA去调用本地的C或者C++实现的方法。

​	注：《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规 定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。

​	与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常。

##### 堆

​	通过new关键字创建的对象都存放在堆内存。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

**特点：**

* **线程共享**，堆内存中的对象都需要考虑线程安全问题
* GC机制

###### 堆内存溢出

​	**java.lang.OutofMemoryError** ：java heap space堆内存溢出。

​	**溢出原因：**假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过`-Xmx`参数配置，若没有特别配置，将会使用默认值。）

​	注：HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在HotSpot虚拟机上是不会由于虚拟机栈无法扩展而导致OutOfMemoryError异常——只要线程申请栈空间成功了就不 会有OOM，但是如果申请时就失败，仍然是会出现OOM异常的。

###### 堆内存诊断

* jps
* jmap
* jconsole
* jvirsalvm

##### 方法区

###### 结构

<img src="https://s2.loli.net/2022/07/05/fS2VsjuOyg4q5bR.png" alt="image-20220705101851463" style="zoom:50%;" />

​	方法区用于存储已被虚拟机加载的**类信息、常量、静态变量**、**即时编译器编译后的代码**等数据。

​	虽然 **Java 虚拟机规范把方法区描述为堆的一个逻辑部分**，但是它却有一个别名叫做 **Non-Heap（非堆）**，目的应该是与 Java 堆区分开来。方法区也被称为永久代(1.8前)。

**特点**

* 线程共享
* 内存溢出：JDK1.8前会导致**永久代**内存溢出，1.8后为**元空间**内存溢出。
* 根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。

###### 常量池

​	组成了二进制字节码，包含了类的基本信息、常量池、类的方法定义（虚拟机指令等)。

​	虚拟机指令根据这张“常量表”找到要执行的类名、方法名、参数类型、字面量信息。

###### 运行时常量池

​	常量池是.class字节码文件中的信息，当该类被加载后，它所对应的常量池信息(编译期生成的各种字面量和符号引用)就会放入运行时常量池，并将里面的#num 符号地址转换为真实地址。

###### 串池StringTable

​	用来放字符串对象且里面的**元素不重复**。(hashtable结构且不可扩容)

###### **特点**

* 常量池中的字符串仅仅是符号，只有在被用到的时候才会转化为对象。
* 利用串池可以避免重复创建字符串对象。
* 字符串**变量**拼接的原理是**StringBuilder。**(变量只能**在运行期确定它的值，所以需要使用StringBuilder来创建**)
* 字符串**常量**拼接的原理是**编译器优化**。(对于常量**javac在编译期会进行优化，结果会在编译期确定**，如果串池中以及存在该值会直接从串池中取值)


###### intern()方法

**intern( )1.8**：调用字符串对象的intern方法，尝试将字符串对象放到串池中

* 若串池中已存在该字符串对象，则直接返回串池中的
* 若串池中还没有该字符串对象则放入成功并返回串池中该字符串对象

​	**例子**

```java
public class Main {
	public static void main(String[] args) {
		//"a" "b" 被放入串池中，str则存在于堆内存之中
		String str = new String("a") + new String("b");
		//调用str的intern方法，这时串池中没有"ab"，则会将该字符串对象放入到串池中，此时堆内存与串池中的"ab"是同一个对象
		String st2 = str.intern();
		//给str3赋值，因为此时串池中已有"ab"，则直接将串池中的内容返回
		String str3 = "ab";
		//因为堆内存与串池中的"ab"是同一个对象，所以以下两条语句打印的都为true
		System.out.println(str == st2);
		System.out.println(str == str3);
	}
}
```

```java
public class Main {
	public static void main(String[] args) {
        //此处创建字符串对象"ab"，因为串池中还没有"ab"，所以将其放入串池中
		String str3 = "ab";
        //"a" "b" 被放入串池中，str则存在于堆内存之中
		String str = new String("a") + new String("b");
        //此时因为在创建str3时，"ab"已存在与串池中，所以放入失败，但是会返回串池中的"ab"
		String str2 = str.intern();
        //false
		System.out.println(str == str2);
        //false
		System.out.println(str == str3);
        //true
		System.out.println(str2 == str3);
	}
}
```



**intern( )1.6**：

* 如果串池中没有该字符串对象，会将该字符串对象**拷贝**一份，再放入到串池中。
* 如果有该字符串对象，则放入失败。

​	区别1.8的是每次调用intern()方法，是将串池或对内存的字符串对象拷贝一份返回。

​	因此，无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象**都不是同一个对象**。

###### StringTable调优

1. StringTable由哈希表实现，因此可以适当**增加哈希表的bucket**的数目，来减少字符串放入串池所需要的时间。
2. 调用**intern( )方法**减少字符串入池的操作。



##### 直接内存

​	直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。

* 操作系统内部，常见于NIO操作，用于数据缓冲区
* 分配、回收成本较高但读写性能高
* 不受JVM的gc机制管理

###### 文件读写流程

<img src="https://s2.loli.net/2022/07/12/jogkKFhT5EPBYdD.png" alt="image-20220712221245343" style="zoom: 50%;" />

###### 使用直接内存

<img src="https://s2.loli.net/2022/07/12/XBYDjwVNieJyQEG.png" alt="image-20220712221425143" style="zoom:50%;" />

​	直接内存是操作系统和Java代码都可以访问到的一块区域，无需将代码从系统内存复制到Java堆内存，从而提高了效率。

###### 释放原理

​	直接内存的回收通过**unsafe.freeMemory**来手动释放内存。

```java
// 通过ByteBuffer申请1M的直接内存
ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);
// 申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？
```

###### allocateDirect的实现

```java
public static ByteBuffer allocateDirect(int capacity) {
    return new DirectByteBuffer(capacity);
}
```

**DirectByteBuffer类**

```java
DirectByteBuffer(int cap) {   // package-private
   
  	.....
    try {
        base = unsafe.allocateMemory(size); //申请内存
    } catch (OutOfMemoryError x) {
        Bits.unreserveMemory(size, cap);
        throw x;
    }
    unsafe.setMemory(base, size, (byte) 0);
    if (pa && (base % ps != 0)) {
        // Round up to page boundary
        address = base + ps - (base & (ps - 1));
    } else {
        address = base;
    }
    cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); //通过虚引用，来实现直接内存的释放，this为虚引用的实际对象
    att = null;
}
```

​	这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存。

​	因此，直接内存的回收机制如下：

* 使用了**Unsafe**类来完成直接内存的分配回收，回收需要主动调用**freeMemory**方法。
* ByteBuffer的实现内部使用了**Cleaner**（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存。



#### 垃圾回收

##### 引用计数法

​	对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。(python采用)

​	例如：对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。

* 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

* 缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
  * 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器无法处理循环引用的情况，这是一条致命缺陷，因此在Java的垃圾回收器中没有使用这类算法。

##### 可达性分析算法

​	可达性分析就是Java、C#选择的。

​		通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“**引用链**”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

​	这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）可达性分析算法也可以称为 根搜索算法、追踪性垃圾收集。

​	相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。

###### 可以作为GC Roots的对象

* 虚拟机栈中引用的对象(栈帧中的本地变量表，例如各个线程被调用的方法堆栈中的参数、局部变量、临时变量等)
* 方法区中类静态属性引用的对象，例如Java类的引用类型静态变量
* 方法区中常量引用的对象，例如字符串常量池中的引用
* 本地方法栈JNI引用的对象
* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
* 所有被同步锁（synchronized关键字）持有的对象
* 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

​	除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不 同，还可以有其他对象**“临时性”**地加入，共同构成完整GC Roots集合。

##### 垃圾回收器

###### 并行和并发

**并行收集：**多条垃圾收集线程并行工作，但此时**用户线程仍处于等待状态**。

**并发收集：**用户线程与垃圾收集线程**同时工作**（不一定并行，可能是交替执行）。**用户程序**继续运行，而垃圾收集程序运行在另一个CPU上。

​	因此，两者的区别在于垃圾回收时用户线程是否被阻塞。

**吞吐量：**吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )，即CPU用于**运行用户代码的时间**与CPU**总消耗时间**的比值。

​	如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%。

###### **吞吐量优先和响应时间优先**

* 共同点：多线程；堆内存较大，多核CPU
* 不同点：
  * 吞吐量优先：单位时间内，STW时间最短。(关注总体上垃圾回收花费的时间少)
  * 响应时间优先：尽可能让单次STW时间变短（尽量不影响其他线程运行)



###### 串行(Serial、Serial old)

**特点**

* 单线程
* 内存较小，适合PC(CPU核数较少)

**Serial回收器**

​	Serial收集器是最基本、历史最悠久的垃圾收集器了，是JDK1.3之前回收新生代唯一的选择。

<img src="https://s2.loli.net/2022/07/17/dXn8THkbRAZfKmy.png" alt="image-20220717125347726" style="zoom: 50%;" />

​	因为是串行的，所以只有一个垃圾回收线程。因此在垃圾回收线程执行回收工作时，其他线程进入**阻塞**状态。

​	注：在HotSpot虚拟机中，使用`-XX：+UseSerialGC`参数可以指定新生代和老年代都使用串行收集器。

​	**特点：**

* 单线程、简单高效(与其他收集器的单线程相比，由于没有线程交互的开销，因此可以专心垃圾回收）

* 采用**复制算法**
* 串行回收
* STW机制(收集器进行垃圾回收时，必须暂停其他所有的工作线程,直到结束)

###### OopMap(ordinary object pointer Map)

​	OopMap 用于枚举GC Roots，记录栈中引用数据类型的位置。

​	所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，而当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为**OopMap**的数据结构来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内**什么偏移量上是什么类型的数据**计算出来，在即时编译过程中，也会**在特定的位置记录下栈里和寄存器里哪些位置是引用。**

​	这样收集器在扫描时就可以**直接**得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。在	**因此，**oopMap主要有以下作用

* **在OopMap的协助下，可以避免全栈扫描，HotSpot可以快速准确地完成GC Roots枚举**
* 可以帮助HotSpot实现**准确式GC**

###### **安全点**

​	因为导致OopMap内容变化的指令非常多，如果为每一条指令都生成 对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本太高。

​	实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，**只是在“特定的位置”记录 了这些信息，这些位置被称为安全点（Safepoint）**。

​	因此，安全点就是指代码中一些特定的位置。当线程运行到这些位置时它的状态是确定的，这样JVM就可以安全的进行一些操作，比如gc等。

​	GC不是想做就做，原子操作代码不可以拆开，例如i++、更新程序计数器。代码设置**线程上**一个安全点，标志从0变1，代码设置几个安全点，到达安全点的时候自动挂起，所有的线程都到达安全点的时候就会开始GC。安全点太少，会让GC等待的时间太长，太多会浪费性能。

​	常见的有：

* 方法返回
* 循环结束
* 进入方法之前
* 抛出异常的时候

**SerialOld回收器**

​	SerialOld收集器提供的用于执行老年代垃圾收集(**JDK1.8默认使用**的垃圾回收器)，不同于Serial的是内存回收算法使用的是**标记-整理**算法。



###### 并行(ParNew、Parallel Scavenge、Parallel old)

<img src="https://s2.loli.net/2022/07/27/h3u8f9H7OlPYeaz.png" alt="image-20220727164047624" style="zoom: 50%;" />

**ParNew**

​	ParNew收集器是serial收集器的多线程版本。(Par是Parallel的缩写，New：只能处理的是新生代)

​	**特点：**

* 多线程(ParNew收集器默认开启的收集线程数与CPU的数量相同)
  * 在CPU非常多的环境中，可以使用`-XX:ParallelGCThreads`参数来限制垃圾收集的线程数

* 复制算法
* 并行回收
* STW机制

​	除Serial外，目前只有ParNew GC能与CMS收集器配合工作。

**Parallel Scavenge 收集器**

​	与吞吐量关系密切，故也称为吞吐量优先收集器。该收集器的目标是达到一个可控制的吞吐量。

**Parallel scavenge特点：**

* 属于新生代收集器也是采用**复制算法**的收集器（用到了新生代的幸存区）

* 是并行的多线程收集器（与ParNew收集器类似）

* **GC自适应调节策略**（与ParNew收集器最重要的一个区别）

  * 可设置`-XX:+UseAdptiveSizePolicy`参数，开启时**不需要**再手动指定新生代的大小（`-Xmn`）、Eden与Survivor区的比例（`-XX:SurvivorRation`）、晋升老年代的对象年龄（`-XX:PretenureSizeThreshold`）等。

    虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供**最优的停顿时间和最高的吞吐量**，这种调节方式称为GC的自适应调节策略。

Parallel Scavenge收集器使用两个参数控制吞吐量	

1. `XX:MaxGCPauseMillis` ：设置最大的垃圾收集停顿时间
2. `XX:GCRatio` ：直接设置吞吐量的大小

**Parallel Old收集器**

​	是Parallel Scavenge收集器的老年代版本。

**特点**：多线程，采用**标记-整理算法**（老年代没有幸存区)。



###### 并发(CMS、G11)

<img src="https://s2.loli.net/2022/07/27/Sl7ZrXaK4fUJExq.png" alt="image-20220727170046430" style="zoom:50%;" />

**CMS收集器**

​	一种以获取**最短回收停顿时间**为目标的**老年代**收集器

**特点：**

* 基于标记-清理算法
* 并发收集、低停顿，但是会产生内存碎片
* 适用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务

**收集过程**

* **初始标记**：标记GC Roots能直接到的对象。速度很快但是仍存在**STW问题**
* **并发标记**：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行
* **重新标记**：**修正并发标记期间**因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在STW问题
* **并发清除**：对标记的对象进行清除回收。CMS收集器的内存回收过程是与用户线程一起**并发执行**的

**G1**

​	JDK 9以后默认使用，而且替代了CMS 收集器。

<img src="https://s2.loli.net/2022/07/27/9ZTh18sGBwPvqp4.png" alt="image-20220727170721297" style="zoom:50%;" />

**特点：**

* 同时注重吞吐量和低延迟（响应时间优先)
* 超大堆内存（内存大的），会将堆内存划分为多个**大小相等**的区域(region)
* 整体上是**标记-整理**算法，两个区域之间是**复制**算法

​	相关参数：`-XX:+UseG1GC`; `-XX:G1HeapRegionSize=size`; `-XX:MaxGCPauserMillis=time`

​	(JDK8 并不是默认开启的，需要设置参数开启)

**G1垃圾回收过程**

<img src="https://s2.loli.net/2022/07/27/98d4ZBIuQRNP5KW.png" alt="image-20220727171256822" style="zoom: 50%;" />

* Young collection， 新生代伊甸园垃圾回收 →

* Young collection + Concurrent Mark, 内存不足,新生代回收+并发标记 →

* Mixed collection,，回收新生代伊甸园、幸存区、老年代内存 →

* Young collection，新生代伊甸园垃圾回收(回到原点，重新开始)

**Young collection**

**分区算法region**

​	分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，**方便控制 GC 产生的停顿时间**。

**Young collection + Concurrent Mark**

<img src="https://s2.loli.net/2022/07/27/S1C5Pk4wJn9mWH6.png" alt="image-20220727173213481" style="zoom: 33%;" />

* 在 Young GC 时会**对 GC Root 进行初始标记**
* 在老年代**占用堆内存的比例**达到阈值时，对堆行并发标记（不会STW），阈值可以根据用户来进行设定

**Mixed collection**

​	会对E S O 区域进行**全面的回收**。

* 最终标记
* 拷贝存活
  * 不是所有的老年代都会被回收：因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会**回收最有价值的老年代**（最有价值指回收后，能够得到更多内存）

**Full GC**

​	G1在老年代内存不足时（老年代所占内存超过阈值）会触发full gc。

* 如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理
* 如果垃圾产生速度快于垃圾回收速度，便会触发Full GC

##### 垃圾回收器总结

* **Serial New收集器**是针对新生代的收集器，采用的是复制算法
* **Parallel New（并行）收集器，**新生代采用复制算法，老年代采用标记整理

* **ParallelScavenge（并行）收集器**，针对新生代，采用复制收集算法

* **Serial Old（串行）收集器**，新生代采用复制，老年代采用标记整理

* **Parallel** **Old（并行）收集器**，针对老年代，标记整理

* **CMS收集器，**基于标记清理

* **G1收集器**：整体上是基于标记整理 ，局部采用复制。

​	**综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。**



##### Young Collection 跨代引用

###### 卡表和remember card

​	如果某个新生代对象存在跨代引用，由于老年代对象难以 消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时 跨代引用也随即被消除了。

​	依据跨代引用假说，我们不应为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称 为“记忆集”，Remembered Set）。

​	这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。

<img src="https://s2.loli.net/2022/07/27/1GxdegVOZ5YmsCu.png" alt="image-20220727183554831" style="zoom: 50%;" />

* Remembered Set 存在于E中，用于保存新生代对象对应的脏卡。(O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡)

<img src="https://s2.loli.net/2022/07/27/Wps2gihdz1AZBqa.png" alt="image-20220727183746248" style="zoom:50%;" />

* 在引用变更时通过post-write barried + dirty card queue。

- concurrent refinement threads 更新 Remembered Set

###### 巨型对象

​	一个对象大于region的一半时，就称为巨型对象。

* G1不会对巨型对象进行拷贝
* 回收时被优先考虑
* G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉

<img src="https://s2.loli.net/2022/07/27/1a6CXre7tRKfgFw.png" alt="image-20220727184144427" style="zoom:50%;" />
