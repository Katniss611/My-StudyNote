### 集合面试总结

#### Vector

​	实现原理和ArrayList相同，功能相同，都是长度可变的数组结构，很多情况下可以互用。

- Vector集合数据存储的结构是数组结构，为JDK中最早提供的集合,它是线程同步的，ArrayList是替代Vector的新接口
- Vector**线程安全**，效率低下；ArrayList重速度轻安全，线程非安全
- 长度需增长时，Vector默认**增长一倍**，ArrayList增长50% 
- Vector中提供了一个独特的取出方式，就是**枚举Enumeration**，它其实就是早期的迭代器。此接口Enumeration的功能与 Iterator 接口的功能是类似的。Vector集合已被ArrayList替代。枚举Enumeration已被迭代器Iterator替代。

###### Q:面试题：Vector和ArrayList的联系和区别 ？

两者的主要区别如下

- Vector是早期JDK接口，ArrayList是替代Vector的新接口
- Vector线程安全效率低下；ArrayList重速度轻安全，线程非安全
- 长度需增长时，Vector默认增长一倍，ArrayList增长50% 

##### Q:说说集合与数组的区别？

- 数组的长度是固定的。集合的长度是可变的
- 数组采用连续存储空间，删除和添加效率低下
- 数组无法直接保存映射关系，集合有多种数据结构（顺序表、链表、哈希表、树等）、多种特征（是否有序，是否唯一）、不同适用场合（查询快，便于删除、有序），不像数组仅采用顺序表方式。
- 数组缺乏封装，操作繁琐 
- 集合存储的元素必须是**引用类型**，数组可以存放任意唯一类型
- 数组无法判断其中实际存有多少元素，length只告诉了array容量；集合可以判断实际存有多少元素，而对总的容量不关心

#### List

##### 迭代器的并发修改异常

​	迭代器的并发修改异常` java.util.ConcurrentModificationException`。不允许在遍历的时候修改集合，因为**容易引发数据的不确定性。**

##### 并发修改异常解决办法

- 在迭代时，不要使用集合的方法操作元素。
- 通过`ListIterator`迭代器操作元素是可以的，`ListIterator`的出现，解决了使用`Iterator`迭代过程中可能会发生的错误情况。

##### ArrayList

###### 底层结构

​	ArrayList 底层数据结构是个数组，里面维护了一个Object 数组` elementData `存放数据，其 API 都做了一层对数组底层访问的封装，允许null值，`modCount`记录数据被修改的版本，有变化就会+1，用于迭代的时候发现并发修改快速失败。

<img src="https://s2.loli.net/2022/08/12/rLNnkygHflmhow2.png" alt="image-20220812151000606" style="zoom: 33%;" />

###### 初始容量是如何设置的？

* 无参数直接初始化：
  * JDK1.7中，使用无参数构造方法创建ArrayList对象时，默认底层数组长度是**10**。
  * JDK1.8中，使用无参数构造方法创建ArrayList对象时，默认底层数组长度是**0**；第一次添加元素，容量不足就要进行扩容了。
* 指定大小初始化：>0 直接初始化对应大小数组，=0 使用空数组，容量为0
* 指定初始数据初始化:
  * 初始化的数据类型是`ArrayList`就直接将内部的`elemen`t指向即可，
  * 其他使用`Arrays.copyOf`(要拷贝的数组 a, 拷贝大小 size, 元素类型 Object[] )拷贝，底层还是使用的 `System.arraycopy`的`native`方法

###### add与扩容

​	add的时候，先计算一下希望的容量大小，容量不足时进行扩容，默认扩容**50%**。如果扩容50%还不足容纳新增元素，就直接使用**期望值**作为大小复制新的数组返回。

###### Q:为什么说扩容会消耗性能？

​	扩容底层使用的是 `System.arraycopy `方法，会把原数组的数据全部拷贝到新数组上。

###### Q:源码扩容过程有什么值得借鉴的地方?

* 通过自动扩容的方式，使用者不用关心底层数据长度的变化，封装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时，也可快速扩容。
* 扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。大于的话add时候直接越界异常。

****

##### LinkedList

​	LinkedList是一个双向链表，LinkedList的索引决定是从链头开始找还是从链尾开始找。如果该元素小于元素长度一半，从链头开始找起，如果大于元素长度的一半，则从链尾找起。

##### 栈和队列的实现类

​	`public  class Stack<E> extends Vector<E>`  Vector过时了，被ArrayList替代了，Stack也就过时了，现在一般更推荐用ArrayDeque实现栈。

###### Q:ArrayList 和 LinkedList 有何不同？

> 从底层数据结构开始说起，然后以某一个方法为突破口深入

- 最大的不同是两者底层的**数据结构**不同，ArrayList 底层是**数组**，LinkedList 底层是**双向链表**，导致了操作的 API 实现有所差异。
  - add 来说，ArrayList 会先计算并决定是否**扩容**，然后把新增的数据直接赋值到数组上，而 LinkedList 仅仅只需要改变插入节点和其前后节点的指向位置关系即可。
- **应用场景上**，ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像工作中经常会对元素进行匹配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景。
- ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存空间的，LinkedList 底层是双向链表，理论上可以无限大。
  - 但源码中，LinkedList 实际大小用的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。
- **ArrayList 允许 null 值新增，也允许 null 值删除**。删除 null 值时，是从头开始，找到第一个值是 null 的元素删除；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的。

###### Q:ArrayList 和 LinkedList 是线程安全的么，为什么？怎么解决？

​	共享变量时，会有线程安全问题。在迭代的过程中，会频繁报`ConcurrentModificationException `的错误，意思是在我当前循环的过程中，数组或链表的结构被其它线程修改了。

​	ArrayList 自身的 `elementData`、`size`、`modConut `在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（`volatile`）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。

**解决方案**

* Collections的synchronizedList 可以解决，`SynchronizedList `是通过在每个方法的方法体里面使用代码块加锁来实现，保证了在同一时刻，数组和链表只会被**一个线程**所修改，虽然实现了线程安全，但是性能大大降低
* **或者采用 CopyOnWriteArrayList 并发 List 来解决。**
  * **此实现中数组被 volatile 关键字修饰，保证了数组内存地址被任意线程修改后，都会通知到其他线程；**
  * **对数组的所有修改操作，都进行了加锁，保证了同一时刻，在 add 时，就无法 remove；**
  * **修改过程中对原数组进行了复制，是在新数组上进行修改的，修改过程中，不会对原数组产生任何影响，避免了并发修改异常**

****

##### CopyOnWriteArrayList

​	`java.util.concurrent.CopyOnWriteArrayList`

- **每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去。操作都是在新拷贝数组上进行的；迭代过程不会被其他线程干扰，也不会抛 ConcurrentModificationException**
- **读操作不加锁**

###### Q:什么是写时复制 COW?

​	当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。

​	这样做的好处是我们可以对`CopyOnWrite`容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以`CopyOnWrite`容器也是一种**读写分离**的思想，读和写不同的容器。 

​	**适用场景：**对于**读操作远远多于写操作**的应用非常适合，特别在并发情况下，可以提供高性能的并发读取。 只能保证数据的最终一致性，不能保证数据实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用。

###### COW 避免了并发修改异常

<img src="https://s2.loli.net/2022/08/12/BYStjX4k7P5ApCn.png" alt="image-20220812162959776" style="zoom: 50%;" />

​	CopyOnWriteArrayList 迭代持有的是老数组的引用，而 CopyOnWriteArrayList 每次的数据变动，都会产生新的数组，对老数组的值不会产生影响，所以迭代也可以正常进行。

###### Q:为什么 CopyOnWriteArrayList 迭代过程中，数组结构变动，不会抛出ConcurrentModificationException 了？

​	每次操作时，都会产生新的数组，而迭代时，持有的仍然是原来数组的引用，即使替换完迭代指向的也是原来的数组，该数组的结构并没有发生变化所以不会抛出异常了。

###### Q:插入的数据正好在 List 的中间，请问ArrayList和CopyOnWriteArrayList 分别拷贝数组几次？为什么？

​	ArrayList 只需拷贝一次，假设插入的位置是 2，只需要把位置 2 （包含 2）后面的数据都往后移动一位即可，所以拷贝一次

​	CopyOnWriteArrayList 拷贝两次，因为把老数组 0 到 2 的数据拷贝到新数组上，预留出新数组 2 的位置，再把老数组 3～ 最后的数据拷贝到新数组上。

###### Q:为什么需要拷贝数组，而不是在原来数组上面加锁进行操作呢？

1. 保证可见性生效：volatile 关键字修饰的是数组，如果我们简单的在原来数组上修改其中某几个元素的值，是无法触发可见性的，我们必须通过修改数组的内存地址才行，也就说要对数组进行重新赋值才行。
2. 提高并发：避免由于老数组用于其他操作中导致的阻塞，效率低下。

****

#### Set

​	它是个**不包含重复元素**的集合。无索引。Set集合取出元素的方式可以采用：迭代器、增强for。

##### 存储结构

- `HashSet` 哈希表 唯一 无序 
- `LinkedHashSet` 哈希表+链表 唯一 有序（添加顺序） 
- `TreeSet` 红黑树 一种二叉平衡树 唯一 有序（自然顺序)

##### HashSet

​	存储的元素是不可重复的，并且元素都是**无序的**(即存取顺序不一致)。`java.util.HashSet`底层的实现**其实是一个**`java.util.HashMap支持HashSet`

​	`HashSet`是根据对象的**哈希值**来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性的方式依赖于：`hashCode`与`equals`方法。

###### HashSet 如何组合 HashMap 的？

​	HashSet 使用的就是组合 HashMap，使用组合而不是继承是因为：

1. 继承表示父子类是同一个事物，而 Set 和 Map 本来就是想表达两种事物，所以继承不妥。
2. 继承难以扩展，组合更加灵活，可以任意的组合现有的基础类，并且可以在基础类方法的基础上进行扩展、编排等，而且方法命名可以任意命名，无需和基础类的方法名称保持一致。尽量多用组合，少用继承。**组合就是把 HashMap 当作自己的一个局部变量。**

###### follow up,组合和继承?

**组合：**

* 组合就是 A类的对象是B类的**成员变量**。相当于 A类对象是B类对象的一个变量，A类中的所有功能，B类都可以通过A类对象的调用来实现。
* 组合体现的是整体与部分、拥有的关系，即` has - a `的关系

**继承：**

* 一个类继承另外的一个类的功能，并可以增加它自己的新功能的能力
* 继承体现的是` is - a` 的关系

###### HashSet存储结构(哈希表)

​	HashSet的底层使用的是HashMap，所以底层结构也是哈希表，hashtable 也叫散列表。相当于`顺序表+链表`。每个顺序表的节点在单独引出一个链表。

- 在无序数组中按照内容查找，效率低下，时间复杂度是O（n） 
- 在有序数组中按照内容查找，可以使用折半查找，时间复杂度O（log2n） 
- 在二叉平衡树中按照内容查找，时间复杂度O（log2n） 
- 在数组中按照索引查找，不进行比较和计数，直接计算得到，效率最高，时间复杂度O（1）

###### hashCode和equals作用？

- `hashCode()`: 计算哈希码，是一个整数，根据哈希码可以计算出数据在哈希表中的存储位置 
- `equals()`：添加时出现了冲突，需要通过equals进行比较，判断是否相同；查询时也需要使用equals进行比较，判断是否相同  

**字符串的hash值计算**

```java
// 字符串对象的哈希值
public int hashCode() {
    // 初始值为 0 
    int h = hash;
    if (h == 0 && value.length > 0) {
        // 字符串对应的 Unicode 编码字符
        char val[] = value;
        // 每一个字符都会对hash值产生一些影响
        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
```

​	之所以使用 31，是因为他是一个奇素数。如果乘数是偶数，并且**乘法溢出**的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。

​	使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。31 有个很好的性能，即用**移位和减法来代替乘法**，可以得到更好的性能：31*i == (i<<5) - i，现代的 VM 可以自动完成这种优化。

**默认的对象hash值**

```java
/*
   *  对象的哈希值,普通的十进制整数，其实就是对象的地址
   *  父类Object,方法 public int hashCode() 计算结果int整数
   */
public class HashDemo {
    public static void main(String[] args) {
        Person p = new Person();
        int i = p.hashCode();
        System.out.println(i);

        String s1 = new String("abc");
        String s2 = new String("abc");
        System.out.println(s1.hashCode());
        System.out.println(s2.hashCode());
    }
}
```

**自定义对象重写hashCode和equals**

​	给HashSet中存放自定义类型元素时，需要重写对象中的`hashCode和equals方法`，建立自己的比较方式，才能保证HashSet集合中的对象**唯一性**。

```java
public class Student {
    private String name;
    private int age;

    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (o == null || getClass() != o.getClass())
            return false;
        Student student = (Student) o;
        return age == student.age &&
               Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

###### 如何减少哈希冲突 

- 哈希表的长度和表中的记录数的比例--装载因子： 如果Hash表的空间远远大于最后实际存储的记录个数，则造成了很大的空间浪费， 如果选取小了的话，则容易造成冲突。 在实际情况中，一般需要根据最终记录存储个数和关键字的分布特点来确定Hash表的大小。还有一种情况是可能事先不知道最终需要存储的记录个数，则需要动态维护Hash表的容量，此时可能需要重新计算Hash地址。**装载因子=表中的记录数/哈希表的长度**， 4/ 16  =0.25  8/ 16=0.5。如果装填因子越小，表明表中还有很多的空单元，则添加发生冲突的可能性越小；而装填因子越大，则发生冲突的可能性就越大，在查找时所耗费的时间就越多。 有相关文献证明当装填因子在0.5左右时候，Hash性能能够达到最优。 因此，一般情况下，装填因子取经验值0.5。 
- 哈希函数的选择 ：直接定址法   平方取中法  折叠法  除留取余法（y = x%11） 
- 处理冲突的方法 ：链地址法  开放地址法  再散列法  建立一个公共溢出区 

###### JDK1.8 之前哈希表实现

- 在JDK1.8之前，哈希表底层采用**数组+链表**实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。
- 加载因子：加载因子是0.75 ，代表数组中的16个位置,其中存入16 x 0.75=12个元素。如果再存入第13个(>12)元素,导致存储链子过长,会降低哈希表的性能,那么此时会扩充哈希表(在哈希)，底层会开辟一个长度为原长度**2倍**的数组,把老元素拷贝到新数组中,再把新元素添加数组中。当存入元素数量>哈希表长度 x 加载因子，就要扩容，**因此加载因子决定扩容时机。**

###### JDK1.8 中哈希表实现

​	而JDK1.8中，哈希表存储采用**数组+链表+红黑树**实现，当链表长度超过阈值（**8**）时，将链表转换为**红黑树**，这样大大减少了查找时间。

###### 哈希表的存储过程

1. 首先调用本类的hashCode()方法算出哈希值
2. 在容器中找是否与新元素哈希值相同的老元素， 如果没有直接存入，如果有转到第三步
3. 新元素会与该索引位置下的旧元素利用 equals 方法一一对比。一旦新元素`.equals(旧元素)`返回true,停止对比，说明重复，不再存入。如果与该索引位置下的老元素都通过equals方法对比返回false,说明没有重复，存入。

##### LinkedHashSet

* 是链表和哈希表组合的一个数据存储结构。
* 存储和取出的顺序相同的。

##### TreeSet

* 采用二叉树（**红黑树**）的存储结构，有序。
* 查询速度比List快（按照**内容**查询），没有`HashSet`快。

​	创建`TreeSet`对象就是创建一个`TreeMap`对象，底层的`TreeMap`的引用。`TreeSet`的元素e是作为`TreeMap`的key存在的，value统一为new Object()。

###### 适用场景

​	一般都是在需要把元素进行排序的时候使用 TreeSet，使用时需要我们注意元素最好实现` Comparable `接口，这样方便底层的 TreeMap 根据 key 进行排序。

###### 所有元素都需要实现 Comparable 接口

​	所有加入到 TreeSet 的对象都需要实现 Comparable 接口。**TreeSet不允许null对象**

###### Q:TreeSet 和 HashSet 两个 Set 内部实现的区别？

* HashSet 底层对 HashMap 的能力进行封装，比如说 add 方法，是直接使用 HashMap 的 put 方法，比较简单，但在初始化的时候，HashMap 初始化大小值的模版公式：取括号内两者的最大值（期望的值 / 0.75+1，默认值 16）。

* TreeSet 主要是对 TreeMap 底层能力进行封装复用，TreeSet 直接使用 TreeMap 的某些功能，自己包装成新的 api。**TreeSet 定义自己想要的 api，自己定义接口规范，让 TreeMap 去实现，**TreeMap 对底层的复杂结构非常清楚，实现起来既准确又简单。

###### Q:几类Set可以存放null？

- HashSet 允许存放一个null
- LinkedHashSet 允许存放一个null
- TreeSet 不允许存放 null

##### CopyOnWriteArraySet

​	**可看作线程安全的HashSet。** 

* `CopyOnWriteArraySet`和`HashSet`虽然都继承于共同的父类`AbstractSet`； 但是HashSet是通过"散列表(`HashMap`)"实现的，而`CopyOnWriteArraySet`则是通过"动态数组(`CopyOnWriteArrayList`)"实现的，并不是散列表。
* `CopyOnWriteArraySet`在`CopyOnWriteArrayList` 的基础上使用了Java的**装饰模式**，所以底层是相同的。而`CopyOnWriteArrayList`本质是个**动态数组队列**，所以`CopyOnWriteArraySet`相当于通过**动态数组**实现的"集合"！ 

* `CopyOnWriteArrayList`额外提供了`addIfAbsent()和addAllAbsent()`这两个添加元素的API，通过这些API来添加元素时，只有当元素不存在时才执行添加操作！ 

****

#### Map

##### Q:Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？

​	这些新增的方法被 `default` 关键字修饰了，`default` 一旦修饰接口上的方法，我们需要在接口的方法中写**默认实现**，并且子类无需强制实现这些方法，所以 Java 7 接口的实现者无需感知。

##### Q:Java 8 中有新增很多实用的方法，你在平时有使用过么？

​	有的，比如说 getOrDefault、putIfAbsent、computeIfPresent 方法等等。

​	比如 computeIfPresent 是可以对 key 和 value 进行计算后，把计算的结果重新赋值给 key，并且如果 key 不存在时，不会报空指针会返回 null 值。

##### Q:Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同？

​	新增的 forEach 方法的入参是函数式的接口，封装了 for 循环的代码，让使用者关注实现循环的业务逻辑，简化了重复的 for 循环代码，使代码更加简洁，普通的 for 循环，每次都需要写重复的 for 循环代码。

##### Map的存储结构

- HashMap<K,V>：`哈希表`结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。
- LinkedHashMap<K,V>：存储数据采用的`哈希表结构+链表`结构。**通过链表结构可以保证元素的存取顺序一致**；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。
- TreeMap：采用二叉树（红黑树）的存储结构，**key有序**  查询速度比List快（按照内容查询） 查询速度没有HashSet快。

##### Q:说说对 HashMap 的理解

* HashMap 用来存储键值对，是线程不安全的，允许 null 值。
* 底层是`数组 + 链表 + 红黑树`的数据结构，数组的主要作用是方便快速查找，时间复杂度是 O(1)，所以get、put 的实现达到了常数的时间，默认大小是 **16**，数组的下标索引是通过 key 的 hashcode 计算出来的。
* 数组元素叫做 Node，当多个 key 的 hashcode 一致，但 key 值不同时，单个 Node 就会转化成链表，链表的查询复杂度是 O(n)，当链表的长度**大于等于 8 并且数组的大小超过 64 时**，链表就会转化成**红黑树**，红黑树的查询复杂度是 O(log(n))，此时，最坏的查询次数相当于红黑树的最大深度。当红黑树的大小小于等于 **6** 时，红黑树会转化成链表。

##### Q:HashMap的初始容量，最大容量是多少？何时转换为红黑树，何时转换为链表？

<img src="https://s2.loli.net/2022/08/15/GJKDZrXLpEwtTBq.png" alt="image-20220815115904813" style="zoom: 50%;" />

##### Q:为什么使用红黑树？

​	红黑树是一种二叉平衡树，二叉树的查找插入都是O(logn)，如果树退化为链表就会退化为O(n)，红黑树在插入的时候可以保证自己是一个接近平衡的二叉树。**红黑树的排序主要是依靠hashcode，compareTo**

​	**红黑树的节点大小是普通节点的两倍，所以只有在桶里面有足够多的数才用。**在删除节点的时候数量变少的时候又会变成普通节点。

##### Q:为什么默认容量设置为16？

​	太大浪费空间，太小会频繁扩容。所以16作为经验值被使用。

##### Q:负载因子为什么是0.75不是0.8或者0.6？

**load factor 是0.75 权衡了空间和时间消耗，高的话减少了空间但是增加了查询开销，hash冲突增加，链表长度变长，小的话浪费空间**。

​	**装载因子=表中的记录数/哈希表的长度**， 例：4/ 16  =0.25  8/ 16=0.5。如果装填因子越小，表明表中还有很多的空单元，则添加发生冲突的可能性越小；而装填因子越大，则发生冲突的可能性就越大，在查找时所耗费的时间就越多。 

##### Q:如何设置初始容量？如何拷贝大的集合？

​	不扩容的条件：initial capacity > 需要的数组大小 / load factor。如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能。

​	给 HashMap 赋初始值的公式为：取括号内两者的最大值`（期望的值/0.75+1，默认值 16）`，**设置的值最终会被扩展为 2 的幂。**

##### Q:HashMap 7 和 8 的主要区别？

* 数据结构的变化：多出了红黑树提高查询的效率。

* 初始化的时机和容量不同：

  * 初始化方面：7 不传参数默认就是初始化**16**大小数组， 8 不传参数默认就是**空的**，用的时候才会初始化数组；
  * 容量：如果用户初始化的时候容量不是2 的幂，7 不会在构造的时候转换而是在 put 的时候，**8 会在初始化的时候就变为2的幂**

* 扩展用户自定义的容量为2的幂不同算法：

  ![image-20220815145313484](https://s2.loli.net/2022/08/15/2UvDkgiNfLsxjAy.png)

*  hash 值的计算方式不同：

  * 7 里面为了避免hash碰撞频繁发生，计算hash的方法比较繁琐。
  * 8 里面引入了红黑树之后，即使hash碰撞频繁发生，转换为红黑树查询效率也很高，没有必要使用复杂的hash 函数增加计算负担，所以直接将高位的数据和低位的**数据异或**，保证高位的信息保留下来同时简化计算。

###### 	Q:为什么hash函数不使用key自己的要另外实现？为什么需要右移 16 位而不是15,17

1. 因为计算index只和hash值的低n位有关，所以要把高位的变化反应到低位上。
2. hashcode 一共32位，hash 算法是 h ^ (h >>> 16)，为了使计算出的 hash 值更分散，所以选择先将 h 无符号右移 16 位，然后再于 h 异或时，就能达到 h 的高 16 位和低 16 位都能参与计算，减少了碰撞的可能性。

###### 	Q:为什么不用 key % 数组大小，而是需要用 key 的 hash 值 % 数组大小。

​	如果 key 是数字没有问题的，但 key 是字符串、复杂对象，这时候用字符串或复杂对象 % 数组大小是不行的，所以需要先计算出 key 的 hash 值。

###### 	Q:为什么把取模操作换成了 & 操作？

​	取模操作处理器计算比较慢，计算机计算取余是一个一个减去的，处理器对 & 操作就比较擅长，提高了处理器处理的速度。

###### 	Q:为什么提倡数组大小是 2 的幂次方？

​	因为只有大小是 2 的幂次方时，才能使 `hash 值 % n(数组大小) == (n-1) & hash` 公式成立。

* put 数据过程不同:

##### Q:为什么链表长度达到8开始尝试转换为红黑树？为什么等到数组长度64而不是直接变红黑树?

1. 好的hash函数桶里面很难达到8的节点，此时链表和树的区别不大，转换为树还有性能和空间（节点占用2倍）开销，超过8就要转换了，因为这个小概率事件发生了，碰撞严重。**通过泊松分布公式计算，正常情况下，链表个数出现 8 的概率不到千万分之一，所以说正常情况下，链表都不会转化成红黑树，这样设计的目的，是为了防止非正常情况下，比如 hash 算法出了问题时，导致链表个数轻易大于等于 8 时，仍然能够快速遍历。**
2. 红黑树占用的空间比链表大很多，转化也比较耗时，所以数组容量小的情况下冲突严重，我们可以先尝试扩容，看看能否通过扩容来解决冲突的问题。**避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。**

##### Q:面试题：红黑树转变成链表为什么是6？

​	节点的个数小于等于 6 时，红黑树会自动转化成链表，主要还是考虑红黑树的空间成本问题，当节点个数小于等于 6 时，遍历链表也很快，所以红黑树会重新变成链表。如果也将该阈值设置于8，那么当hash碰撞在8时，会反生链表和红黑树的不停相互激荡转换，白白浪费资源。

​	是6不是8是为了**避免频繁的切换**。若转换长度在8之间来回浮动代价很大。

##### Q:HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？

​	如果数组有了 key，但不想覆盖 value ，可以选择 `putIfAbsent`方法，这个方法有个内置变量` onlyIfAbsent`，内置是` true` ，就不会覆盖，我们平时使用的 put 方法，内置 onlyIfAbsent 为 false，是允许覆盖的。

##### Q:JDK8中HashMap 扩容的时机？

1. put 时，发现数组为空，进行初始化扩容，默认扩容大小为 16;
2. put时候，发现当前链表的长度大于8而数组长度小于64时候，扩容数组。
3. put 成功后，发现现有数组大小大于扩容的阀值时，进行扩容，扩容为老数组大小的 **2 倍**;扩容的门阀是 threshold，每次扩容时 threshold 都会被重新计算，门阀值等于数组的大小 x 装载因子（0.75）。